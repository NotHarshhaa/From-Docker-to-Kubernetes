---
title: Images
description: Learn about Docker images, Dockerfiles, and image management
icon: 'lucide:image'
---

## Docker Images

Docker images are the building blocks of containers. They are read-only templates containing:
- Application code
- Runtime environment
- Dependencies
- Configuration

## Working with Dockerfiles

A Dockerfile is a text document containing all commands to build an image:

```dockerfile
# Use an official Python runtime as the base image
FROM python:3.9-slim

# Set working directory
WORKDIR /app

# Copy requirements file
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Command to run the application
CMD ["python", "app.py"]
```

## Building Images

::steps
### Basic Build Command
```bash
docker build -t my-app:1.0 .
```

### Build with Different Dockerfile
```bash
docker build -f Dockerfile.dev -t my-app:dev .
```

### Build with Build Arguments
```bash
docker build --build-arg ENV=production -t my-app:prod .
```
::

## Image Management

```bash
# List images
docker images

# Remove image
docker rmi <image-id>

# Pull image from registry
docker pull <image-name>

# Push image to registry
docker push <image-name>

# Tag image
docker tag <source-image> <target-image>
```

## Multi-stage Builds

Multi-stage builds help create smaller production images:

```dockerfile
# Build stage
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## Best Practices

::alert{type="info"}
1. Use specific base image tags
2. Minimize layer count
3. Use .dockerignore
4. Order commands by change frequency
5. Use multi-stage builds for production
:: 