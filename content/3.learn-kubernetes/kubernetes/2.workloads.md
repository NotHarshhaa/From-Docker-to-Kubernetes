---
title: Workloads
description: Understanding Kubernetes workload resources and their management
icon: 'lucide:box'
---

## Kubernetes Workloads

Kubernetes provides several resource types to manage containerized applications.

## Core Workload Resources

::steps
### Pods
- Smallest deployable unit
- Contains one or more containers
- Shares network and storage

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

### Deployments
- Manages ReplicaSets
- Handles rolling updates
- Provides rollback capability

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
```

### StatefulSets
- For stateful applications
- Provides stable network identities
- Ordered deployment and scaling

### DaemonSets
- Runs pods on all nodes
- Used for cluster services
- Automatic pod scheduling
::

## Workload Management

::steps
### Scaling
```bash
# Scale deployment
kubectl scale deployment nginx-deployment --replicas=5

# Autoscaling
kubectl autoscale deployment nginx-deployment --min=2 --max=5 --cpu-percent=80
```

### Updates
```bash
# Rolling update
kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1

# Rollback
kubectl rollout undo deployment/nginx-deployment
```

### Health Checks
```yaml
spec:
  containers:
  - name: app
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
```
::

## Resource Management

::steps
### Resource Requests
```yaml
resources:
  requests:
    memory: "64Mi"
    cpu: "250m"
```

### Resource Limits
```yaml
resources:
  limits:
    memory: "128Mi"
    cpu: "500m"
```

### Quality of Service
- Guaranteed
- Burstable
- BestEffort
::

## Best Practices

::alert{type="info"}
1. Always set resource requests and limits
2. Use health checks for reliability
3. Implement proper labels and selectors
4. Plan for high availability
5. Use namespaces for resource isolation
:: 